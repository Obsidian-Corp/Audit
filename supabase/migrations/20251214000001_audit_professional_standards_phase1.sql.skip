-- =====================================================
-- OBSIDIAN AUDIT PLATFORM - PROFESSIONAL STANDARDS PHASE 1
-- Critical Infrastructure: Workflow Enforcement, Sign-off Integrity, Versioning
-- Standards: PCAOB AS 1215, AS 1201, ISA 230, AU-C 230
-- =====================================================

-- =====================================================
-- PART 1: WORKPAPER VERSIONING SYSTEM
-- Requirement: Complete audit trail of all workpaper changes
-- =====================================================

-- Workpaper Versions Table
CREATE TABLE IF NOT EXISTS workpaper_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workpaper_id UUID NOT NULL,
  version_number INTEGER NOT NULL,
  content JSONB NOT NULL,
  content_hash TEXT NOT NULL, -- SHA-256 hash of content for integrity
  changed_by UUID REFERENCES auth.users(id),
  change_summary TEXT,
  change_type TEXT DEFAULT 'edit', -- 'create', 'edit', 'restore', 'auto_save'
  created_at TIMESTAMPTZ DEFAULT NOW(),
  firm_id UUID NOT NULL,

  CONSTRAINT unique_workpaper_version UNIQUE(workpaper_id, version_number)
);

-- Index for efficient version lookups
CREATE INDEX IF NOT EXISTS idx_workpaper_versions_workpaper_id ON workpaper_versions(workpaper_id);
CREATE INDEX IF NOT EXISTS idx_workpaper_versions_firm_id ON workpaper_versions(firm_id);
CREATE INDEX IF NOT EXISTS idx_workpaper_versions_changed_by ON workpaper_versions(changed_by);

-- =====================================================
-- PART 2: IMMUTABLE SIGN-OFF RECORDS WITH CONTENT HASHING
-- Requirement: Prove what was signed, invalidate on change
-- =====================================================

-- Sign-off Records (Immutable audit trail)
CREATE TABLE IF NOT EXISTS signoff_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Entity being signed
  entity_type TEXT NOT NULL, -- 'workpaper', 'procedure', 'section', 'program', 'engagement', 'report'
  entity_id UUID NOT NULL,

  -- Sign-off details
  signoff_level TEXT NOT NULL, -- 'preparer', 'reviewer', 'manager', 'partner', 'eqcr'
  signed_by UUID NOT NULL REFERENCES auth.users(id),
  signed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Content integrity
  content_hash TEXT NOT NULL, -- SHA-256 of content at moment of signing

  -- Validity tracking
  is_valid BOOLEAN DEFAULT true,
  invalidated_at TIMESTAMPTZ,
  invalidated_by UUID REFERENCES auth.users(id),
  invalidated_reason TEXT,

  -- Audit metadata
  ip_address INET,
  user_agent TEXT,

  -- Comments/Notes
  signoff_comments TEXT,

  -- Organization
  firm_id UUID NOT NULL,
  engagement_id UUID,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for sign-off queries
CREATE INDEX IF NOT EXISTS idx_signoff_records_entity ON signoff_records(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_signoff_records_engagement ON signoff_records(engagement_id);
CREATE INDEX IF NOT EXISTS idx_signoff_records_signed_by ON signoff_records(signed_by);
CREATE INDEX IF NOT EXISTS idx_signoff_records_valid ON signoff_records(is_valid) WHERE is_valid = true;
CREATE INDEX IF NOT EXISTS idx_signoff_records_firm ON signoff_records(firm_id);

-- =====================================================
-- PART 3: TICK MARKS SYSTEM
-- Requirement: Standard audit tick marks with cross-references
-- =====================================================

-- Tick Mark Definitions (per engagement or firm-wide)
CREATE TABLE IF NOT EXISTS tick_mark_definitions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  firm_id UUID NOT NULL,
  engagement_id UUID, -- NULL for firm-wide definitions

  symbol TEXT NOT NULL, -- '√', 'F', 'XF', 'T', 'A', 'C', 'R', '?', 'PY', 'N/A', custom
  meaning TEXT NOT NULL,
  description TEXT,
  is_standard BOOLEAN DEFAULT false, -- True for industry-standard marks
  display_order INTEGER DEFAULT 0,

  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT unique_tick_mark UNIQUE(firm_id, engagement_id, symbol)
);

-- Tick Mark Usage (actual tick marks placed in workpapers)
CREATE TABLE IF NOT EXISTS tick_mark_usages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workpaper_id UUID NOT NULL,
  tick_mark_definition_id UUID REFERENCES tick_mark_definitions(id),

  -- Location in workpaper
  cell_reference TEXT, -- Row:Col or range, or element ID
  position_data JSONB, -- {x, y, width, height} for visual positioning

  -- Cross-reference links
  linked_evidence_id UUID, -- Link to supporting document
  linked_workpaper_id UUID, -- Link to another workpaper
  linked_procedure_id UUID, -- Link to procedure
  link_description TEXT,

  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  firm_id UUID NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_tick_marks_workpaper ON tick_mark_usages(workpaper_id);
CREATE INDEX IF NOT EXISTS idx_tick_marks_firm ON tick_mark_usages(firm_id);

-- =====================================================
-- PART 4: WORKPAPER CROSS-REFERENCES
-- Requirement: Link workpapers, evidence, and procedures
-- =====================================================

CREATE TABLE IF NOT EXISTS workpaper_cross_references (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Source
  source_workpaper_id UUID NOT NULL,
  source_cell_reference TEXT, -- Specific location in source

  -- Target
  target_type TEXT NOT NULL, -- 'workpaper', 'evidence', 'procedure', 'finding', 'adjustment'
  target_id UUID NOT NULL,
  target_cell_reference TEXT, -- Specific location in target (if applicable)

  -- Reference details
  reference_code TEXT, -- Display code like "A-1", "B.2.3", "PBC-15"
  reference_description TEXT,

  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  firm_id UUID NOT NULL,
  engagement_id UUID NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_cross_refs_source ON workpaper_cross_references(source_workpaper_id);
CREATE INDEX IF NOT EXISTS idx_cross_refs_target ON workpaper_cross_references(target_type, target_id);
CREATE INDEX IF NOT EXISTS idx_cross_refs_engagement ON workpaper_cross_references(engagement_id);

-- =====================================================
-- PART 5: EVIDENCE INTEGRITY (SHA-256 HASHING)
-- Requirement: Verify evidence has not been tampered
-- =====================================================

-- Add hash columns to documents table if not exists
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'documents' AND column_name = 'file_hash_sha256') THEN
    ALTER TABLE documents ADD COLUMN file_hash_sha256 TEXT;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'documents' AND column_name = 'hash_verified_at') THEN
    ALTER TABLE documents ADD COLUMN hash_verified_at TIMESTAMPTZ;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'documents' AND column_name = 'hash_verification_status') THEN
    ALTER TABLE documents ADD COLUMN hash_verification_status TEXT DEFAULT 'pending';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'documents' AND column_name = 'is_immutable') THEN
    ALTER TABLE documents ADD COLUMN is_immutable BOOLEAN DEFAULT false;
  END IF;
END $$;

-- Evidence Access Log (Chain of Custody)
CREATE TABLE IF NOT EXISTS evidence_access_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  evidence_id UUID NOT NULL,

  -- Access details
  accessed_by UUID NOT NULL REFERENCES auth.users(id),
  access_type TEXT NOT NULL, -- 'view', 'download', 'verify', 'link', 'print'
  accessed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Verification
  hash_at_access TEXT, -- Hash computed during access (for verification)
  hash_matches BOOLEAN, -- Did it match original?

  -- Audit metadata
  ip_address INET,
  user_agent TEXT,

  firm_id UUID NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_evidence_access_evidence ON evidence_access_log(evidence_id);
CREATE INDEX IF NOT EXISTS idx_evidence_access_user ON evidence_access_log(accessed_by);
CREATE INDEX IF NOT EXISTS idx_evidence_access_time ON evidence_access_log(accessed_at);

-- =====================================================
-- PART 6: PROCEDURE STATUS STATE MACHINE
-- Requirement: Enforce valid status transitions
-- =====================================================

-- Valid procedure status transitions
CREATE TABLE IF NOT EXISTS procedure_status_transitions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  from_status TEXT NOT NULL,
  to_status TEXT NOT NULL,
  required_role TEXT, -- Minimum role required for this transition
  required_fields TEXT[], -- Fields that must be populated
  requires_all_review_notes_resolved BOOLEAN DEFAULT false,
  description TEXT,

  CONSTRAINT unique_transition UNIQUE(from_status, to_status)
);

-- Insert standard transitions per AU-C 330
INSERT INTO procedure_status_transitions (from_status, to_status, required_role, required_fields, requires_all_review_notes_resolved, description)
VALUES
  ('not_started', 'in_progress', 'staff', '{}', false, 'Begin working on procedure'),
  ('in_progress', 'not_started', 'staff', '{}', false, 'Reset procedure'),
  ('in_progress', 'pending_review', 'staff', '{work_performed,conclusion}', false, 'Submit for review'),
  ('pending_review', 'in_progress', 'senior', '{}', false, 'Return for rework'),
  ('pending_review', 'reviewed', 'senior', '{}', true, 'Complete first-level review'),
  ('reviewed', 'in_progress', 'manager', '{}', false, 'Return for additional work'),
  ('reviewed', 'signed_off', 'manager', '{}', true, 'Final sign-off'),
  ('signed_off', 'in_progress', 'partner', '{}', false, 'Reopen signed procedure (requires partner)')
ON CONFLICT (from_status, to_status) DO NOTHING;

-- Procedure transition history
CREATE TABLE IF NOT EXISTS procedure_status_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  procedure_id UUID NOT NULL,
  from_status TEXT,
  to_status TEXT NOT NULL,
  transitioned_by UUID REFERENCES auth.users(id),
  transitioned_at TIMESTAMPTZ DEFAULT NOW(),
  reason TEXT,
  firm_id UUID NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_procedure_history_procedure ON procedure_status_history(procedure_id);

-- =====================================================
-- PART 7: REVIEW NOTES ENFORCEMENT
-- Requirement: Cannot sign off with open review notes
-- =====================================================

-- Add resolution requirement tracking to review_notes if not exists
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'review_notes' AND column_name = 'resolution_required') THEN
    ALTER TABLE review_notes ADD COLUMN resolution_required BOOLEAN DEFAULT true;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'review_notes' AND column_name = 'blocks_signoff') THEN
    ALTER TABLE review_notes ADD COLUMN blocks_signoff BOOLEAN DEFAULT true;
  END IF;
END $$;

-- =====================================================
-- PART 8: ENGAGEMENT ASSEMBLY AND LOCKING
-- Requirement: Lock workpapers after assembly deadline (45/60 days)
-- =====================================================

-- Add assembly tracking to engagements if not exists
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'engagements' AND column_name = 'assembly_deadline') THEN
    ALTER TABLE engagements ADD COLUMN assembly_deadline DATE;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'engagements' AND column_name = 'assembled_at') THEN
    ALTER TABLE engagements ADD COLUMN assembled_at TIMESTAMPTZ;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'engagements' AND column_name = 'assembled_by') THEN
    ALTER TABLE engagements ADD COLUMN assembled_by UUID REFERENCES auth.users(id);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'engagements' AND column_name = 'is_locked') THEN
    ALTER TABLE engagements ADD COLUMN is_locked BOOLEAN DEFAULT false;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'engagements' AND column_name = 'lock_reason') THEN
    ALTER TABLE engagements ADD COLUMN lock_reason TEXT;
  END IF;
END $$;

-- =====================================================
-- PART 9: IMMUTABLE AUDIT LOG
-- Requirement: Audit logs cannot be deleted or modified
-- =====================================================

-- Revoke DELETE on activity_log (make immutable)
-- Note: This needs to be run with proper permissions
DO $$
BEGIN
  -- Create a more comprehensive audit log if it doesn't exist
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'immutable_audit_log') THEN
    CREATE TABLE immutable_audit_log (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

      -- Action details
      action TEXT NOT NULL, -- 'create', 'update', 'delete', 'view', 'sign', 'export'
      entity_type TEXT NOT NULL,
      entity_id UUID,

      -- User and context
      user_id UUID REFERENCES auth.users(id),
      firm_id UUID,
      engagement_id UUID,

      -- Change details
      old_values JSONB,
      new_values JSONB,

      -- Audit metadata
      ip_address INET,
      user_agent TEXT,
      session_id TEXT,

      -- Integrity
      previous_entry_hash TEXT, -- Hash of previous log entry (chain)
      entry_hash TEXT, -- Hash of this entry

      -- Timestamp
      created_at TIMESTAMPTZ DEFAULT NOW(),

      -- Ensure immutability
      CONSTRAINT no_future_dates CHECK (created_at <= NOW())
    );

    -- Index for efficient queries
    CREATE INDEX idx_immutable_log_entity ON immutable_audit_log(entity_type, entity_id);
    CREATE INDEX idx_immutable_log_user ON immutable_audit_log(user_id);
    CREATE INDEX idx_immutable_log_engagement ON immutable_audit_log(engagement_id);
    CREATE INDEX idx_immutable_log_time ON immutable_audit_log(created_at);
  END IF;
END $$;

-- =====================================================
-- PART 10: HELPER FUNCTIONS
-- =====================================================

-- Function to compute content hash (SHA-256)
CREATE OR REPLACE FUNCTION compute_content_hash(content JSONB)
RETURNS TEXT AS $$
BEGIN
  RETURN encode(sha256(content::text::bytea), 'hex');
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Function to create workpaper version on save
CREATE OR REPLACE FUNCTION create_workpaper_version()
RETURNS TRIGGER AS $$
DECLARE
  new_version INTEGER;
  content_hash TEXT;
BEGIN
  -- Only create version if content actually changed
  IF OLD.content IS DISTINCT FROM NEW.content THEN
    -- Get next version number
    SELECT COALESCE(MAX(version_number), 0) + 1 INTO new_version
    FROM workpaper_versions
    WHERE workpaper_id = NEW.id;

    -- Compute hash
    content_hash := compute_content_hash(NEW.content);

    -- Insert version record
    INSERT INTO workpaper_versions (
      workpaper_id,
      version_number,
      content,
      content_hash,
      changed_by,
      change_type,
      firm_id
    ) VALUES (
      NEW.id,
      new_version,
      NEW.content,
      content_hash,
      auth.uid(),
      'edit',
      NEW.firm_id
    );

    -- Invalidate any existing sign-offs on this workpaper
    UPDATE signoff_records
    SET
      is_valid = false,
      invalidated_at = NOW(),
      invalidated_by = auth.uid(),
      invalidated_reason = 'Content modified after sign-off'
    WHERE entity_type = 'workpaper'
      AND entity_id = NEW.id
      AND is_valid = true;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to validate procedure status transition
CREATE OR REPLACE FUNCTION validate_procedure_transition()
RETURNS TRIGGER AS $$
DECLARE
  transition_record RECORD;
  user_role TEXT;
  open_notes_count INTEGER;
BEGIN
  -- Skip if status didn't change
  IF OLD.status = NEW.status THEN
    RETURN NEW;
  END IF;

  -- Check if transition is valid
  SELECT * INTO transition_record
  FROM procedure_status_transitions
  WHERE from_status = OLD.status AND to_status = NEW.status;

  IF transition_record IS NULL THEN
    RAISE EXCEPTION 'Invalid status transition from % to %', OLD.status, NEW.status;
  END IF;

  -- Check required fields
  IF transition_record.required_fields IS NOT NULL AND array_length(transition_record.required_fields, 1) > 0 THEN
    IF 'work_performed' = ANY(transition_record.required_fields) AND NEW.work_performed IS NULL THEN
      RAISE EXCEPTION 'Work performed is required before status can be changed to %', NEW.status;
    END IF;
    IF 'conclusion' = ANY(transition_record.required_fields) AND NEW.conclusion IS NULL THEN
      RAISE EXCEPTION 'Conclusion is required before status can be changed to %', NEW.status;
    END IF;
  END IF;

  -- Check review notes resolution requirement
  IF transition_record.requires_all_review_notes_resolved THEN
    SELECT COUNT(*) INTO open_notes_count
    FROM review_notes
    WHERE procedure_id = NEW.id
      AND status IN ('open', 'pending')
      AND blocks_signoff = true;

    IF open_notes_count > 0 THEN
      RAISE EXCEPTION 'Cannot change status to % with % open review notes', NEW.status, open_notes_count;
    END IF;
  END IF;

  -- Log the transition
  INSERT INTO procedure_status_history (
    procedure_id, from_status, to_status, transitioned_by, reason, firm_id
  ) VALUES (
    NEW.id, OLD.status, NEW.status, auth.uid(),
    'Status changed via application', NEW.firm_id
  );

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to log evidence access
CREATE OR REPLACE FUNCTION log_evidence_access(
  p_evidence_id UUID,
  p_access_type TEXT,
  p_hash_at_access TEXT DEFAULT NULL,
  p_ip_address INET DEFAULT NULL,
  p_user_agent TEXT DEFAULT NULL
)
RETURNS void AS $$
DECLARE
  original_hash TEXT;
  hash_matches BOOLEAN;
  v_firm_id UUID;
BEGIN
  -- Get original hash and firm_id
  SELECT file_hash_sha256, firm_id INTO original_hash, v_firm_id
  FROM documents
  WHERE id = p_evidence_id;

  -- Check if hash matches
  IF p_hash_at_access IS NOT NULL AND original_hash IS NOT NULL THEN
    hash_matches := (p_hash_at_access = original_hash);
  ELSE
    hash_matches := NULL;
  END IF;

  -- Log the access
  INSERT INTO evidence_access_log (
    evidence_id, accessed_by, access_type, hash_at_access,
    hash_matches, ip_address, user_agent, firm_id
  ) VALUES (
    p_evidence_id, auth.uid(), p_access_type, p_hash_at_access,
    hash_matches, p_ip_address, p_user_agent, v_firm_id
  );

  -- Alert if hash doesn't match (potential tampering)
  IF hash_matches = false THEN
    -- Could trigger notification or alert here
    RAISE WARNING 'Evidence integrity check failed for document %', p_evidence_id;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to create sign-off record
CREATE OR REPLACE FUNCTION create_signoff(
  p_entity_type TEXT,
  p_entity_id UUID,
  p_signoff_level TEXT,
  p_content_hash TEXT,
  p_comments TEXT DEFAULT NULL,
  p_engagement_id UUID DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_signoff_id UUID;
  v_firm_id UUID;
  existing_signoff UUID;
BEGIN
  -- Check for existing valid sign-off at this level
  SELECT id INTO existing_signoff
  FROM signoff_records
  WHERE entity_type = p_entity_type
    AND entity_id = p_entity_id
    AND signoff_level = p_signoff_level
    AND is_valid = true;

  IF existing_signoff IS NOT NULL THEN
    RAISE EXCEPTION 'Valid sign-off already exists at level % for this entity', p_signoff_level;
  END IF;

  -- Get firm_id from entity
  -- This would need to be adapted based on entity type
  SELECT firm_id INTO v_firm_id
  FROM engagements
  WHERE id = COALESCE(p_engagement_id, p_entity_id)
  LIMIT 1;

  -- Create the sign-off record
  INSERT INTO signoff_records (
    entity_type, entity_id, signoff_level, signed_by, content_hash,
    signoff_comments, firm_id, engagement_id
  ) VALUES (
    p_entity_type, p_entity_id, p_signoff_level, auth.uid(), p_content_hash,
    p_comments, v_firm_id, p_engagement_id
  )
  RETURNING id INTO v_signoff_id;

  RETURN v_signoff_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if entity can be signed off (all prerequisites met)
CREATE OR REPLACE FUNCTION can_signoff(
  p_entity_type TEXT,
  p_entity_id UUID,
  p_signoff_level TEXT
)
RETURNS TABLE (
  can_sign BOOLEAN,
  blockers TEXT[]
) AS $$
DECLARE
  v_blockers TEXT[] := '{}';
  v_can_sign BOOLEAN := true;
  open_notes INTEGER;
  required_prior_signoffs TEXT[];
  missing_signoffs TEXT[];
BEGIN
  -- Check for open review notes (if entity has them)
  IF p_entity_type IN ('procedure', 'workpaper') THEN
    SELECT COUNT(*) INTO open_notes
    FROM review_notes
    WHERE (procedure_id = p_entity_id OR workpaper_id = p_entity_id)
      AND status IN ('open', 'pending')
      AND blocks_signoff = true;

    IF open_notes > 0 THEN
      v_can_sign := false;
      v_blockers := array_append(v_blockers, format('%s open review notes must be resolved', open_notes));
    END IF;
  END IF;

  -- Check for required prior sign-offs based on level
  IF p_signoff_level = 'reviewer' THEN
    required_prior_signoffs := ARRAY['preparer'];
  ELSIF p_signoff_level = 'manager' THEN
    required_prior_signoffs := ARRAY['preparer', 'reviewer'];
  ELSIF p_signoff_level = 'partner' THEN
    required_prior_signoffs := ARRAY['preparer', 'reviewer', 'manager'];
  ELSE
    required_prior_signoffs := '{}';
  END IF;

  -- Check each required prior sign-off exists and is valid
  SELECT array_agg(level) INTO missing_signoffs
  FROM unnest(required_prior_signoffs) AS level
  WHERE NOT EXISTS (
    SELECT 1 FROM signoff_records
    WHERE entity_type = p_entity_type
      AND entity_id = p_entity_id
      AND signoff_level = level
      AND is_valid = true
  );

  IF missing_signoffs IS NOT NULL AND array_length(missing_signoffs, 1) > 0 THEN
    v_can_sign := false;
    v_blockers := array_append(v_blockers, format('Missing required sign-offs: %s', array_to_string(missing_signoffs, ', ')));
  END IF;

  RETURN QUERY SELECT v_can_sign, v_blockers;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- PART 11: RLS POLICIES FOR NEW TABLES
-- =====================================================

-- Enable RLS
ALTER TABLE workpaper_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE signoff_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE tick_mark_definitions ENABLE ROW LEVEL SECURITY;
ALTER TABLE tick_mark_usages ENABLE ROW LEVEL SECURITY;
ALTER TABLE workpaper_cross_references ENABLE ROW LEVEL SECURITY;
ALTER TABLE evidence_access_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE procedure_status_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE immutable_audit_log ENABLE ROW LEVEL SECURITY;

-- RLS Policies for workpaper_versions
CREATE POLICY "Users can view workpaper versions in their firm"
  ON workpaper_versions FOR SELECT
  USING (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

CREATE POLICY "Users can create workpaper versions in their firm"
  ON workpaper_versions FOR INSERT
  WITH CHECK (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

-- RLS Policies for signoff_records
CREATE POLICY "Users can view sign-offs in their firm"
  ON signoff_records FOR SELECT
  USING (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

CREATE POLICY "Users can create sign-offs in their firm"
  ON signoff_records FOR INSERT
  WITH CHECK (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

CREATE POLICY "Users can update sign-offs they created"
  ON signoff_records FOR UPDATE
  USING (signed_by = auth.uid() OR
         firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid() AND role IN ('admin', 'partner')));

-- RLS Policies for tick_mark_definitions
CREATE POLICY "Users can view tick marks in their firm"
  ON tick_mark_definitions FOR SELECT
  USING (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

CREATE POLICY "Users can manage tick marks in their firm"
  ON tick_mark_definitions FOR ALL
  USING (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

-- RLS Policies for tick_mark_usages
CREATE POLICY "Users can view tick mark usages in their firm"
  ON tick_mark_usages FOR SELECT
  USING (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

CREATE POLICY "Users can manage tick mark usages in their firm"
  ON tick_mark_usages FOR ALL
  USING (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

-- RLS Policies for cross_references
CREATE POLICY "Users can view cross references in their firm"
  ON workpaper_cross_references FOR SELECT
  USING (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

CREATE POLICY "Users can manage cross references in their firm"
  ON workpaper_cross_references FOR ALL
  USING (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

-- RLS Policies for evidence_access_log
CREATE POLICY "Users can view evidence access logs in their firm"
  ON evidence_access_log FOR SELECT
  USING (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

CREATE POLICY "System can insert evidence access logs"
  ON evidence_access_log FOR INSERT
  WITH CHECK (true);

-- RLS Policies for procedure_status_history
CREATE POLICY "Users can view procedure history in their firm"
  ON procedure_status_history FOR SELECT
  USING (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

CREATE POLICY "System can insert procedure history"
  ON procedure_status_history FOR INSERT
  WITH CHECK (true);

-- RLS Policies for immutable_audit_log
CREATE POLICY "Users can view audit logs in their firm"
  ON immutable_audit_log FOR SELECT
  USING (firm_id IN (SELECT firm_id FROM firm_users WHERE user_id = auth.uid()));

CREATE POLICY "System can insert audit logs"
  ON immutable_audit_log FOR INSERT
  WITH CHECK (true);

-- Prevent deletion of audit logs
CREATE POLICY "No one can delete audit logs"
  ON immutable_audit_log FOR DELETE
  USING (false);

-- Prevent updates to audit logs
CREATE POLICY "No one can update audit logs"
  ON immutable_audit_log FOR UPDATE
  USING (false);

-- =====================================================
-- PART 12: INSERT STANDARD TICK MARKS
-- =====================================================

-- Create a function to seed standard tick marks for a firm
CREATE OR REPLACE FUNCTION seed_standard_tick_marks(p_firm_id UUID)
RETURNS void AS $$
BEGIN
  INSERT INTO tick_mark_definitions (firm_id, symbol, meaning, description, is_standard, display_order)
  VALUES
    (p_firm_id, '√', 'Traced and agreed', 'Traced to supporting documentation and agreed without exception', true, 1),
    (p_firm_id, 'F', 'Footed', 'Mathematical accuracy verified (column/row totals)', true, 2),
    (p_firm_id, 'XF', 'Cross-footed', 'Cross-footed (horizontal and vertical totals agreed)', true, 3),
    (p_firm_id, 'T', 'Traced', 'Traced to source document', true, 4),
    (p_firm_id, 'A', 'Agreed', 'Agreed to prior year / other source', true, 5),
    (p_firm_id, 'C', 'Confirmed', 'Confirmed with third party', true, 6),
    (p_firm_id, 'R', 'Recalculated', 'Independently recalculated', true, 7),
    (p_firm_id, 'I', 'Inspected', 'Physically inspected', true, 8),
    (p_firm_id, 'O', 'Observed', 'Observed in operation', true, 9),
    (p_firm_id, '?', 'Question/Follow-up', 'Requires follow-up or clarification', true, 10),
    (p_firm_id, 'PY', 'Prior Year', 'Agreed to prior year workpapers', true, 11),
    (p_firm_id, 'N/A', 'Not Applicable', 'Procedure not applicable', true, 12),
    (p_firm_id, 'TB', 'Traced to Trial Balance', 'Agreed to trial balance', true, 13),
    (p_firm_id, 'GL', 'Traced to General Ledger', 'Agreed to general ledger', true, 14),
    (p_firm_id, 'SL', 'Traced to Subledger', 'Agreed to subledger', true, 15)
  ON CONFLICT (firm_id, engagement_id, symbol) DO NOTHING;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- MIGRATION COMPLETE
-- =====================================================

COMMENT ON TABLE workpaper_versions IS 'Complete version history of all workpaper changes per AS 1215';
COMMENT ON TABLE signoff_records IS 'Immutable sign-off records with content hashing per AS 1201';
COMMENT ON TABLE tick_mark_definitions IS 'Standard and custom tick mark definitions';
COMMENT ON TABLE tick_mark_usages IS 'Tick marks placed in workpapers with cross-references';
COMMENT ON TABLE workpaper_cross_references IS 'Cross-reference links between workpapers, evidence, and procedures';
COMMENT ON TABLE evidence_access_log IS 'Chain of custody log for all evidence access';
COMMENT ON TABLE procedure_status_transitions IS 'Valid procedure status transitions per AU-C 330';
COMMENT ON TABLE procedure_status_history IS 'History of all procedure status changes';
COMMENT ON TABLE immutable_audit_log IS 'Immutable audit trail for regulatory compliance';
